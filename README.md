# Golang basic

## Tasks

1. [Дана структура Human (с произвольным набором полей и методов). Реализовать встраивание методов в структуре Action от родительской структуры Human (аналог наследования).](task01/main.go)
2. [Написать программу, которая конкурентно рассчитает значение квадратов чисел взятых из массива (2,4,6,8,10) и выведет их квадраты в stdout.](task02/main.go)
3. [Дана последовательность чисел: 2,4,6,8,10. Найти сумму их квадратов(22+32+42….) с использованием конкурентных вычислений.](task03/main.go)
4. [Реализовать постоянную запись данных в канал (главный поток). Реализовать набор из N воркеров, которые читают произвольные данные из канала и выводят в stdout. Необходима возможность выбора количества воркеров при старте.\
Программа должна завершаться по нажатию Ctrl+C. Выбрать и обосновать способ завершения работы всех воркеров.](task04/main.go)
5. [Разработать программу, которая будет последовательно отправлять значения в канал, а с другой стороны канала — читать. По истечению N секунд программа должна завершаться.](task05/main.go)
6. [Реализовать все возможные способы остановки выполнения горутины.](task06)
7. [Реализовать конкурентную запись данных в map.](task07/main.go)
8. [Дана переменная int64. Разработать программу которая устанавливает i-й бит в 1 или 0.](task08/main.go)
9. [Разработать конвейер чисел. Даны два канала: в первый пишутся числа (x) из массива, во второй — результат операции x*2, после чего данные из второго канала должны выводиться в stdout.](task09/main.go)
10. [Дана последовательность температурных колебаний: -25.4, -27.0 13.0, 19.0, 15.5, 24.5, -21.0, 32.5. Объединить данные значения в группы с шагом в 10 градусов. Последовательность в подмножноствах не важна.\
Пример: -20:{-25.0, -27.0, -21.0}, 10:{13.0, 19.0, 15.5}, 20: {24.5}, etc.](task10/main.go)
11. [Реализовать пересечение двух неупорядоченных множеств.](task11/main.go)
12. [Имеется последовательность строк - (cat, cat, dog, cat, tree) создать для нее собственное множество.](task12/main.go)
13. [Поменять местами два числа без создания временной переменной.](task13/main.go)
14. [Разработать программу, которая в рантайме способна определить тип переменной: int, string, bool, channel из переменной типа interface{}.](task14/main.go)
15. [К каким негативным последствиям может привести данный фрагмент кода, и как это исправить? Приведите корректный пример реализации.](task15/main.go)
16. [К каким негативным последствРеализовать быструю сортировку массива (quicksort) встроенными методами языка.](task16/main.go)
17. [Реализовать бинарный поиск встроенными методами языка.](task17/main.go)
18. [Реализовать структуру-счетчик, которая будет инкрементироваться в конкурентной среде. По завершению программа должна выводить итоговое значение счетчика.](task18/main.go)
19. [Разработать программу, которая переворачивает подаваемую на ход строку (например: «главрыба — абырвалг»). Символы могут быть unicode.](task19/main.go)
20. [Разработать программу, которая переворачивает слова в строке.
    Пример: «snow dog sun — sun dog snow».](task20/main.go)
21. [Реализовать паттерн «адаптер» на любом примере.](task21/main.go)
22. [Разработать программу, которая перемножает, делит, складывает, вычитает две числовых переменных a,b, значение которых > 2^20.](task22/main.go)
23. [Удалить i-ый элемент из слайса.](task22/main.go)
24. [Разработать программу нахождения расстояния между двумя точками, которые представлены в виде структуры Point с инкапсулированными параметрами x,y и конструктором.](task23/main.go)
25. [Реализовать собственную функцию sleep.](task25/main.go) 
26. [Разработать программу, которая проверяет, что все символы в строке уникальные (true — если уникальные, false etc). Функция проверки должна быть регистронезависимой.
    иям может привести данный фрагмент кода, и как это исправить? Приведите корректный пример реализации.](task26/main.go)

## Questions

1. Какой самый эффективный способ конкатенации строк

```go
s := strings.Builder{}
s.WriteString("hello ")
s.WriteString("world")
fmt.Println(s.String())
```

2. Что такое интерфейсы, как они применяются в Go?

>Интерфейсы это инструменты для определения наборов действий и поведения. Они позволяют объектам опираться на абстракции, а не фактические реализации других объектов. При этом для компоновки различных поведений можно группировать несколько интерфейсов.

3. Чем отличаются RWMutex от Mutex?

>RWMutex применяется со структурами, безопасными для параллельного чтения, но небезопасными для записи. RWMutex позволяет не блокировать чтение, если в данный момент не идёт запись.

4. Чем отличаются буферизированные и не буферизированные каналы?

>При отправке сообщения в небуферизированный канал поток блокируется и ждёт, когда кто-то извлечёт сообщение. В буферизированном канале поток блокируется когда буфер заполнен полностью

5. Какой размер у структуры struct{}{}?

```go
s := struct{}{}
fmt.Printf("%v\n", unsafe.Sizeof(s))
```

>0

6. Есть ли в Go перегрузка методов или операторов?

>В Go нет перегрузки методов и функций. Предлагается просто давать разные имена методам и функциям.

7. В какой последовательности будут выведены элементы map[int]int?

Пример:

```go
m[0]=1
m[1]=124
m[2]=281
```

>Рандомно

8. В чем разница make и new?

> - `make` используется для создания `slice, map, chan`, `new` - для всего
> - `make` возвращает сам объект, `new` выделяет память и возвращает указатель на созданный объект

9. Сколько существует способов задать переменную типа slice или map?

```go
var first []string
second := []string{}
fourth := make([]string, 0)
third := new([]string)
```

```go
var first map[int]int
second := map[string]int{}
fourth := make(map[string]int)
third := new(map[string]int)
```

10. Что выведет данная программа и почему?

```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```

> 1 1\
> В `update()` меняется не значение по указателю, а значение самого указателя, которое остаётся в локальной видимости  

11. Что выведет данная программа и почему?

```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```

> 0..4 в рандомном порядке, далее deadlock, т.к. в горутину передан `WaitGroup`, а не указатель на него

12. Что выведет данная программа и почему?

```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```

> 0\
> В блоке if создается локальная переменная 

13. Что выведет данная программа и почему?

```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```

> [100 2 3 4 5]\
> При append создается новый slice, не затронут оригинальный slice


14. Что выведет данная программа и почему?

```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```

> [b b a][a a]\
> slice в анонимной функции перекрывает slice в main, обновляется и выводится [b b a], slice в main не изменялся - выводится [a a]
